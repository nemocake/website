<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Book Component Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            background: #0a0a0a;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #fff;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 40px;
        }

        #canvas-container {
            width: 100%;
            height: 500px;
            background: #111;
            border: 1px solid #222;
            position: relative;
        }

        canvas {
            display: block;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 24px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666;
        }

        .control-group input[type="range"] {
            width: 150px;
            accent-color: #ff4c00;
        }

        .control-group input[type="color"] {
            width: 60px;
            height: 30px;
            border: 1px solid #333;
            background: transparent;
            cursor: pointer;
        }

        .control-group select {
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        .info {
            margin-top: 40px;
            padding: 20px;
            background: #111;
            border: 1px solid #222;
            font-size: 13px;
            line-height: 1.6;
            color: #888;
        }

        .info code {
            background: #1a1a1a;
            padding: 2px 6px;
            font-family: monospace;
            color: #02b0f4;
        }

        .texture-upload {
            margin-top: 24px;
            padding: 20px;
            background: #111;
            border: 1px solid #222;
        }

        .texture-upload h3 {
            font-size: 14px;
            margin-bottom: 12px;
        }

        .upload-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .upload-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .upload-item label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666;
        }

        .upload-item input[type="file"] {
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3D Book Component</h1>
        <p class="subtitle">Three.js book mockup with spine depth and page texture</p>

        <div id="canvas-container"></div>

        <div class="controls">
            <div class="control-group">
                <label>Book Width</label>
                <input type="range" id="bookWidth" min="1" max="4" step="0.1" value="2.4">
            </div>
            <div class="control-group">
                <label>Book Height</label>
                <input type="range" id="bookHeight" min="2" max="5" step="0.1" value="3.2">
            </div>
            <div class="control-group">
                <label>Spine Depth</label>
                <input type="range" id="spineDepth" min="0.1" max="1" step="0.05" value="0.35">
            </div>
            <div class="control-group">
                <label>Cover Color</label>
                <input type="color" id="coverColor" value="#011015">
            </div>
            <div class="control-group">
                <label>Spine Color</label>
                <input type="color" id="spineColor" value="#ff4c00">
            </div>
            <div class="control-group">
                <label>Page Color</label>
                <input type="color" id="pageColor" value="#f5f2e8">
            </div>
            <div class="control-group">
                <label>Rotation</label>
                <select id="autoRotate">
                    <option value="true">Auto-rotate</option>
                    <option value="false">Manual only</option>
                </select>
            </div>
        </div>

        <div class="texture-upload">
            <h3>Cover Textures (optional)</h3>
            <div class="upload-row">
                <div class="upload-item">
                    <label>Front Cover</label>
                    <input type="file" id="frontCoverTexture" accept="image/*">
                </div>
                <div class="upload-item">
                    <label>Back Cover</label>
                    <input type="file" id="backCoverTexture" accept="image/*">
                </div>
                <div class="upload-item">
                    <label>Spine</label>
                    <input type="file" id="spineTexture" accept="image/*">
                </div>
            </div>
        </div>

        <div class="info">
            <strong>Controls:</strong> Click and drag to rotate. Scroll to zoom.<br><br>
            <strong>Structure:</strong> The book is built from multiple geometries:
            <ul style="margin-top: 8px; margin-left: 20px;">
                <li>Front cover (box with slight thickness)</li>
                <li>Back cover (box with slight thickness)</li>
                <li>Spine (curved or flat box connecting covers)</li>
                <li>Pages block (cream-colored with striped texture for edge detail)</li>
            </ul>
            <br>
            <strong>Integration:</strong> This can be exported as a reusable component.
            Key files: <code>Book3D.js</code> class + <code>three.module.js</code>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // =====================================================================
        // BOOK 3D CLASS
        // =====================================================================

        class Book3D {
            constructor(options = {}) {
                this.options = {
                    width: options.width || 2.4,
                    height: options.height || 3.2,
                    depth: options.depth || 0.35,
                    coverThickness: options.coverThickness || 0.03,
                    coverColor: options.coverColor || 0x011015,
                    spineColor: options.spineColor || 0xff4c00,
                    pageColor: options.pageColor || 0xf5f2e8,
                    pageLineColor: options.pageLineColor || 0xe0ddd0,
                    ...options
                };

                this.group = new THREE.Group();
                this.textures = {};
                this.materials = {};

                this.createMaterials();
                this.createBook();
            }

            createMaterials() {
                const { coverColor, spineColor, pageColor, pageLineColor } = this.options;

                // Cover material - slightly glossy
                this.materials.cover = new THREE.MeshStandardMaterial({
                    color: coverColor,
                    roughness: 0.4,
                    metalness: 0.0,
                });

                // Spine material
                this.materials.spine = new THREE.MeshStandardMaterial({
                    color: spineColor,
                    roughness: 0.5,
                    metalness: 0.0,
                });

                // Page block material - matte paper
                this.materials.pages = new THREE.MeshStandardMaterial({
                    color: pageColor,
                    roughness: 0.9,
                    metalness: 0.0,
                });

                // Page edge material with stripe texture
                this.materials.pageEdge = this.createPageEdgeMaterial(pageColor, pageLineColor);
            }

            createPageEdgeMaterial(pageColor, lineColor) {
                // Create a canvas texture for page lines
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Background
                ctx.fillStyle = '#' + pageColor.toString(16).padStart(6, '0');
                ctx.fillRect(0, 0, 512, 512);

                // Draw horizontal lines to simulate page edges
                ctx.strokeStyle = '#' + lineColor.toString(16).padStart(6, '0');
                ctx.lineWidth = 1;

                for (let i = 0; i < 512; i += 4) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(512, i);
                    ctx.stroke();
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 10);

                return new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.95,
                    metalness: 0.0,
                });
            }

            createBook() {
                const { width, height, depth, coverThickness } = this.options;

                // Calculate dimensions
                const pageBlockDepth = depth - (coverThickness * 2);
                const pageBlockWidth = width - 0.05; // Slightly inset from cover
                const pageBlockHeight = height - 0.02;

                // Front Cover
                const frontCoverGeo = new THREE.BoxGeometry(width, height, coverThickness);
                const frontCover = new THREE.Mesh(frontCoverGeo, this.materials.cover);
                frontCover.position.z = depth / 2 - coverThickness / 2;
                frontCover.name = 'frontCover';
                this.group.add(frontCover);

                // Back Cover
                const backCoverGeo = new THREE.BoxGeometry(width, height, coverThickness);
                const backCover = new THREE.Mesh(backCoverGeo, this.materials.cover);
                backCover.position.z = -depth / 2 + coverThickness / 2;
                backCover.name = 'backCover';
                this.group.add(backCover);

                // Spine
                const spineGeo = new THREE.BoxGeometry(coverThickness, height, depth);
                const spine = new THREE.Mesh(spineGeo, this.materials.spine);
                spine.position.x = -width / 2 + coverThickness / 2;
                spine.name = 'spine';
                this.group.add(spine);

                // Pages block - using different materials for different faces
                const pagesGeo = new THREE.BoxGeometry(pageBlockWidth, pageBlockHeight, pageBlockDepth);

                // Create materials array for each face
                // Order: +X, -X, +Y, -Y, +Z, -Z (right, left, top, bottom, front, back)
                const pagesMaterials = [
                    this.materials.pageEdge, // Right edge (main visible page edges)
                    this.materials.pages,     // Left (against spine)
                    this.materials.pageEdge, // Top edge
                    this.materials.pageEdge, // Bottom edge
                    this.materials.pages,     // Front (against front cover)
                    this.materials.pages,     // Back (against back cover)
                ];

                const pages = new THREE.Mesh(pagesGeo, pagesMaterials);
                pages.position.x = (coverThickness - 0.05) / 2; // Offset from spine
                pages.name = 'pages';
                this.group.add(pages);

                // Add subtle bevel/shadow strips along page edges for depth
                this.addPageEdgeDetail(pageBlockWidth, pageBlockHeight, pageBlockDepth);
            }

            addPageEdgeDetail(blockWidth, blockHeight, blockDepth) {
                // Thin dark strip at the edge where pages meet cover
                const edgeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.3
                });

                // Top edge shadow
                const topEdgeGeo = new THREE.PlaneGeometry(blockWidth, blockDepth);
                const topEdge = new THREE.Mesh(topEdgeGeo, edgeMaterial);
                topEdge.rotation.x = -Math.PI / 2;
                topEdge.position.y = blockHeight / 2 + 0.001;
                topEdge.position.x = (this.options.coverThickness - 0.05) / 2;
                this.group.add(topEdge);
            }

            setTexture(part, texture) {
                const partMap = {
                    'front': 'frontCover',
                    'back': 'backCover',
                    'spine': 'spine'
                };

                const meshName = partMap[part];
                if (!meshName) return;

                const mesh = this.group.getObjectByName(meshName);
                if (mesh && mesh.material) {
                    mesh.material.map = texture;
                    mesh.material.needsUpdate = true;
                }
            }

            updateDimensions(width, height, depth) {
                // Remove old book
                while (this.group.children.length > 0) {
                    const child = this.group.children[0];
                    if (child.geometry) child.geometry.dispose();
                    this.group.remove(child);
                }

                // Update options
                this.options.width = width;
                this.options.height = height;
                this.options.depth = depth;

                // Recreate
                this.createBook();
            }

            updateColors(coverColor, spineColor, pageColor) {
                this.materials.cover.color.setHex(coverColor);
                this.materials.spine.color.setHex(spineColor);
                this.materials.pages.color.setHex(pageColor);

                // Recreate page edge texture with new color
                if (this.materials.pageEdge.map) {
                    this.materials.pageEdge.map.dispose();
                }
                this.materials.pageEdge = this.createPageEdgeMaterial(pageColor, 0xe0ddd0);

                // Update pages mesh materials
                const pages = this.group.getObjectByName('pages');
                if (pages) {
                    pages.material = [
                        this.materials.pageEdge,
                        this.materials.pages,
                        this.materials.pageEdge,
                        this.materials.pageEdge,
                        this.materials.pages,
                        this.materials.pages,
                    ];
                }
            }

            getObject() {
                return this.group;
            }

            dispose() {
                this.group.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => {
                                if (m.map) m.map.dispose();
                                m.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                });
            }
        }

        // =====================================================================
        // SCENE SETUP
        // =====================================================================

        const container = document.getElementById('canvas-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        // Camera
        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
        camera.position.set(4, 2, 5);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1;
        controls.minDistance = 3;
        controls.maxDistance = 15;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(5, 8, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-3, 4, -3);
        scene.add(fillLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
        rimLight.position.set(0, -2, -5);
        scene.add(rimLight);

        // Ground plane for shadow
        const groundGeo = new THREE.PlaneGeometry(20, 20);
        const groundMat = new THREE.ShadowMaterial({ opacity: 0.3 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Create book
        let book = new Book3D({
            width: 2.4,
            height: 3.2,
            depth: 0.35,
            coverColor: 0x011015,
            spineColor: 0xff4c00,
            pageColor: 0xf5f2e8
        });

        const bookObj = book.getObject();
        bookObj.rotation.y = Math.PI * 0.1;
        bookObj.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        scene.add(bookObj);

        // =====================================================================
        // CONTROLS BINDING
        // =====================================================================

        const widthInput = document.getElementById('bookWidth');
        const heightInput = document.getElementById('bookHeight');
        const depthInput = document.getElementById('spineDepth');
        const coverColorInput = document.getElementById('coverColor');
        const spineColorInput = document.getElementById('spineColor');
        const pageColorInput = document.getElementById('pageColor');
        const autoRotateSelect = document.getElementById('autoRotate');

        function hexToInt(hex) {
            return parseInt(hex.replace('#', ''), 16);
        }

        widthInput.addEventListener('input', () => {
            book.updateDimensions(
                parseFloat(widthInput.value),
                parseFloat(heightInput.value),
                parseFloat(depthInput.value)
            );
        });

        heightInput.addEventListener('input', () => {
            book.updateDimensions(
                parseFloat(widthInput.value),
                parseFloat(heightInput.value),
                parseFloat(depthInput.value)
            );
        });

        depthInput.addEventListener('input', () => {
            book.updateDimensions(
                parseFloat(widthInput.value),
                parseFloat(heightInput.value),
                parseFloat(depthInput.value)
            );
        });

        coverColorInput.addEventListener('input', () => {
            book.updateColors(
                hexToInt(coverColorInput.value),
                hexToInt(spineColorInput.value),
                hexToInt(pageColorInput.value)
            );
        });

        spineColorInput.addEventListener('input', () => {
            book.updateColors(
                hexToInt(coverColorInput.value),
                hexToInt(spineColorInput.value),
                hexToInt(pageColorInput.value)
            );
        });

        pageColorInput.addEventListener('input', () => {
            book.updateColors(
                hexToInt(coverColorInput.value),
                hexToInt(spineColorInput.value),
                hexToInt(pageColorInput.value)
            );
        });

        autoRotateSelect.addEventListener('change', () => {
            controls.autoRotate = autoRotateSelect.value === 'true';
        });

        // Texture uploads
        const textureLoader = new THREE.TextureLoader();

        document.getElementById('frontCoverTexture').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                textureLoader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    book.setTexture('front', texture);
                });
            }
        });

        document.getElementById('backCoverTexture').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                textureLoader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    book.setTexture('back', texture);
                });
            }
        });

        document.getElementById('spineTexture').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                textureLoader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    book.setTexture('spine', texture);
                });
            }
        });

        // =====================================================================
        // ANIMATION LOOP
        // =====================================================================

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // =====================================================================
        // RESIZE HANDLER
        // =====================================================================

        window.addEventListener('resize', () => {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        });

    </script>
</body>
</html>
